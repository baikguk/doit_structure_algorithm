1. 선형검색 : 배열을 순차적으로 검색

 	종료 조건
	1. 검색값 발견 못해 배열 끝까지 갔을때
	if(i==num){
		return == -1
           	 }
 	2. 검색값 발견 
	if(a[i]==key){
             	   return i;
            }

		ㄴ 해당 방법 시 for문안에 2번의 if문 사용
			ㄴ if문 횟수를 줄이기 위해 보초법 사용

	보초법 : 배열 마지막에 찾는 값을 넣음
			ㄴ 이를 통해 검색시 무조건 값을 찾음 


2. 이진 검색 : sort 된 배열에서 검색, pl (검색 범위의 첫번째), pc(검색 범위의 중간),pr(검색범위의 끝)
		ㄴ ex) 이진 검색 시작시 pl=0, pc=(n-1)/2, pr=n-1
순서 a[pc] , key 비교 -> 값이 작으면 a[pl]~a[pc] 로 검색 범위 줄임 
					-> 반복 후 a[pc] 값과 key동일할 경우 값을 찾음

	종료 조건
		1. a[pc] 값과 key과 일치시 검색 성공
		2. 일치하는 값이 없고 pl값 pr보다 커질 시

3. 복잡도(시간 복잡도, 공간 복잡도)
	선형 검색 시간 복잡도 평균 n/2 -> O(n)
				ㄴ n이 무한이 커진 경우 n/2와 n의 차이는 별로 없음
	이진 검색 시간 복잡도 평균 log n
		ㄴ 반복할 때마다 검색 범위가 절반이 되기 때문
	
	전체 시간 복잡도 계산
		O(f(n)) + O(g(n)) = O(max(f(n),g(n))) -> 가장 차수가 높은 복잡도

4. API 문서란
	API 라이브러를 작성한 쪽에서 사용하는 방법을 적어 놓은 것

5. 이전검색에서의 대소관계 메소드
static int binarySearch(Object[] a, Object key) : 자연 정렬된 배열에서 대소관계 판단 후 검색
					  ㄴ 정수배열,문자열 배열
	ㄴ 문자열에서 대소관계가 가능한 이유 : Comparable<T> 인터페이스에 정의된 
								compareTo(T c) 메소드와 equals(Object c)구현했기 때문

static int binarySearch(T[] a, T key, Comparator<? super T> c) : 자연 정렬되지 않은 배열에서 사용
						ㄴ 클래스의 배열
	ㄴ 대소관계 판단법을 정의해줘야하기 때문에
		 인터페이스 Comparator을 구현한 클래스를 정의 후 클래스 생성해서 전달
인터페이스 멤버변수(private final) 메소드 (private static)

6. Generics : 처리 데이터의 자료형에 의존하지 않도록 클래스를 구현하는 기능

7. 자바의 메소드 호출 : 스텍을 사용

8. Java Enum : 여러 상수를 한번에 정의함
	Ex) public static final Day{
   		 MON("Monday"), TUE("Tuesday"), WED("Wednesday";
9. 링버퍼(큐) : 기존 선형 큐는 de-queue를 하면 0번째 인덱스가 빠져나가 나머지는 인덱스가 앞으로
		shift를 하게되어 시간복잡도 O(n)이 걸리는 비효율적인 상황이 나옴
		이를 해결하기 위해 링 버퍼로 큐로 만듬(시간 복잡도 O(1))
	링버퍼는 맨앞과 맨끝이 연결된 자료구조 따라서 맨앞 맨뒤 구분을 위해 front,rear로 구분함
	front,rear만으로는 큐가 비었는지 다 찼는지 모름으로(두 경우 모두 front,rear 값이 동일함)
	큐가 얼마나 찼는지 알려주는 num또한 사용함

	배열로 링버퍼 구현시 인덱스 순환 논리-> (i+front)%capacity

10.재귀 알고리즘 : 
	직접 재귀: 자기가 본인 메소드 호출
	간접 재귀: 각기 다른 메소드들이 서로를 호출
	순수 재귀: 자기가 본인 메소드를 여러번 호출 

	하향식 분석: 코드의 호출 순서에 따라 계단식으로 분석하는 기법
	상향식 분석: 코드의 호출 순서와 상관없이 메소드 파라미터를 쌓아올리면서 분석하는 기법

11. 분기 조작법 : 문제를 작게 나누고 세분된 작은 문제의 풀이를 결합해 전체 문제를 풀이
     분기 한정법

12 정렬(교환 선택 삽입) : 
	내부 정렬 -> 데이터를 하나의 배열에 저장하여 정렬할 수 경우
	외부 정렬 -> 데이터가 많아 하나의 배열에 저장하여 정렬할 수 없는 경우
	
	버블 정렬 -> 이웃한 두 요소의 대소 관계를 비교하여 정렬(단순 교환 정렬)
			->  1~n-1 합 n(n-1)/2 -> 교환 횟수의 평균 (1/2)
			->  교환 시 3회 발생
		     	== 시간 복잡도 3n(n-1)/4
 
	단순 선택 정렬 -> 가장 작은 요소를 선택해 맨앞의 요소와 교환 -> 반복
		        -> 시간 복잡도 n(n-1)/2
			 	ㄴ 한계점: 중복되는 요소가 있을 시 안정적이지 않음(바꿔줄 필요없는데 바꿔서)

	단순 삽입 정렬, 셀정렬 

	퀵정렬 : 가장 빠른 정렬 알고리즘
		-> pl,pr, 피벗 값을 기준으로 크기로 배열을 나누어 정렬
		-> 분할후 재귀하여 반복 수행 -> 비재귀 방법으로 스텍 사용
		-> 요솟수가 많은 그룹을 먼저 푸시하면, 적은 그룹이 먼저 정렬 -> 스텍의 깊이가 낮아짐
									 ㄴ 데이터가 수백만개여도 스텍 용량은 20으로 충분
		-> 3개의 요소를 선택해 정렬 후 퀵정렬시 시간복잡도 nlog(n) 최악의 경우 n^2

	병합정렬 : 배열의 요솟수가 2개까지 나눈후 대소 비교 및 병합하여 정렬
		  -> 정렬된 배열의 병합과정에서의 시간복잡도는 O(n)
			->이후 배열을 나누며 정렬의 시각복잡도느 log(n)임으로 총 시간 복잡도는 nlog(n)
			-> 서로 떨어져있는 요소를 교환하는 경우가 없기 때문에 안정적인 정렬 방법임

	Array.sort() : 
			-> primitive 타입 배열의 경우 안정적이지 않음( 퀵 정렬)
			-> 클래스 객체 배열(병합 정렬) 안정적
				-> 자연스러운 순서의 경우
					 static void sort(Object[] a) or static void sort(Object[] a,int fromIndex, toIndex)
				-> 부자연스러운 순서의 경우
					static <T> void sort(T[] a, Comparator<? super T> c) 
					static void sort(T[] a,, int fromIndex, int toIndex,  Comparator<? super T> c)

	힙 정렬 : 힙 -> 부모값이 자식 보다 항상 크다라는 조건을 만족하는 완전이진     (완전 : 부모가 자식을 왼쪽부터 추가, 이진 : 자식2개)
								          트리(트리의 가장 윗부분 : 루트)
		   -> 부모 자식의 관계는 일정하지만, 형제 사이의 대소관계는 일정하지 않음(동일 형제에서 왼쪽값이 클수도)
		   -> 단순 선택 시간 복잡도 O(n^2) 힙정렬 시간 복잡도 (nlog(n))

	도수 정렬 : 요소의 대소관계를 판단하지 않고, 빠르게 정렬 (도수분포표->누적도수분포표->목표 배열 생성 -> 배열 복사) 4단계로 구현
		

					 
13. 문자열 검색
	브루트-포스법  : 선형검색을 확장한 알고리즘 (단순법, 소박법) 특정 문자열 패턴을 배열 인덱스 순서로 검색
	부호화(encoding : 정보의 모양이나 형식을 다른 모양이나 형식으로 변환 ->표준화,보안 ,처리 속도 향상, 저장 공간 절약 등에 사용
			ex) str.getBytes() -> 문자열을 바이트 시퀀스로 부호화하여 바이트 배열에 넣어둠
								ㄴ 인코딩 방식에 따라 한글 2바이트(euc-kr), 3바이트(utf-8)
							ㄴ 바이트 시퀀스는 기계가 처리하는 문자 형식 ->문자를 표현하는 바이트