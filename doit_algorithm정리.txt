1. 선형검색 : 배열을 순차적으로 검색

 	종료 조건
	1. 검색값 발견 못해 배열 끝까지 갔을때
	if(i==num){
		return == -1
           	 }
 	2. 검색값 발견 
	if(a[i]==key){
             	   return i;
            }

		ㄴ 해당 방법 시 for문안에 2번의 if문 사용
			ㄴ if문 횟수를 줄이기 위해 보초법 사용

	보초법 : 배열 마지막에 찾는 값을 넣음
			ㄴ 이를 통해 검색시 무조건 값을 찾음 


2. 이진 검색 : sort 된 배열에서 검색, pl (검색 범위의 첫번째), pc(검색 범위의 중간),pr(검색범위의 끝)
		ㄴ ex) 이진 검색 시작시 pl=0, pc=(n-1)/2, pr=n-1
순서 a[pc] , key 비교 -> 값이 작으면 a[pl]~a[pc] 로 검색 범위 줄임 
					-> 반복 후 a[pc] 값과 key동일할 경우 값을 찾음

	종료 조건
		1. a[pc] 값과 key과 일치시 검색 성공
		2. 일치하는 값이 없고 pl값 pr보다 커질 시

3. 복잡도(시간 복잡도, 공간 복잡도)
	선형 검색 시간 복잡도 평균 n/2 -> O(n)
				ㄴ n이 무한이 커진 경우 n/2와 n의 차이는 별로 없음
	이진 검색 시간 복잡도 평균 log n
		ㄴ 반복할 때마다 검색 범위가 절반이 되기 때문
	
	전체 시간 복잡도 계산
		O(f(n)) + O(g(n)) = O(max(f(n),g(n))) -> 가장 차수가 높은 복잡도

4. API 문서란
	API 라이브러를 작성한 쪽에서 사용하는 방법을 적어 놓은 것

5. 이전검색에서의 대소관계 메소드
static int binarySearch(Object[] a, Object key) : 자연 정렬된 배열에서 대소관계 판단 후 검색
					  ㄴ 정수배열,문자열 배열
	ㄴ 문자열에서 대소관계가 가능한 이유 : Comparable<T> 인터페이스에 정의된 
								compareTo(T c) 메소드와 equals(Object c)구현했기 때문
					Comparable : 객체 자신과 T타입을 비교함

static int binarySearch(T[] a, T key, Comparator<? super T> c) : 자연 정렬되지 않은 배열에서 사용
						ㄴ 클래스의 배열
	ㄴ 대소관계 판단법을 정의해줘야하기 때문에
		 인터페이스 Comparator을 구현한 클래스를 정의 후 클래스 생성해서 전달
		 Comparator은 자기 객체와는 상관 없이 입력받는 두 객체를 비교함 (compare<T o1, T o2> 오버라이딩함)
인터페이스 멤버변수(private final) 메소드 (private static)

6. Generics : 처리 데이터의 자료형에 의존하지 않도록 클래스를 구현하는 기능

7. 자바의 메소드 호출 : 스텍을 사용

8. Java Enum : 여러 상수를 한번에 정의함(열거체)
	Ex) public static final Day{
   		 MON(1), TUE(2), WED(3);
	
	     enum Menu {
       		 ADD_FISRT(   "머리에 노드를 삽입"),
	             ADD_LAST(    "꼬리에 노드를 삽입"),
	             RMV_FIRST(   "머리 노드를 삭제");
		}

	Enum 메소드 : Enum.values, Enum.ordinal
		Menu.values() : 해당 상수를 저장하는 배열을 생성하여 반환(ADD_FIRST, ADD_LAST)
		Menu.ADD_FIRST.ordinal() : 해당 열거체가 정의된 순서를 반환 (0,1,2)

9. 링버퍼(큐) : 기존 선형 큐는 de-queue를 하면 0번째 인덱스가 빠져나가 나머지는 인덱스가 앞으로
		shift를 하게되어 시간복잡도 O(n)이 걸리는 비효율적인 상황이 나옴
		이를 해결하기 위해 링 버퍼로 큐로 만듬(시간 복잡도 O(1))
	링버퍼는 맨앞과 맨끝이 연결된 자료구조 따라서 맨앞 맨뒤 구분을 위해 front,rear로 구분함
	front,rear만으로는 큐가 비었는지 다 찼는지 모름으로(두 경우 모두 front,rear 값이 동일함)
	큐가 얼마나 찼는지 알려주는 num또한 사용함

	배열로 링버퍼 구현시 인덱스 순환 논리-> (i+front)%capacity

10.재귀 알고리즘 : 
	직접 재귀: 자기가 본인 메소드 호출
	간접 재귀: 각기 다른 메소드들이 서로를 호출
	순수 재귀: 자기가 본인 메소드를 여러번 호출 

	하향식 분석: 코드의 호출 순서에 따라 계단식으로 분석하는 기법
	상향식 분석: 코드의 호출 순서와 상관없이 메소드 파라미터를 쌓아올리면서 분석하는 기법

11. 분기 조작법 : 문제를 작게 나누고 세분된 작은 문제의 풀이를 결합해 전체 문제를 풀이
     분기 한정법

12 정렬(교환 선택 삽입) : 
	내부 정렬 -> 데이터를 하나의 배열에 저장하여 정렬할 수 경우
	외부 정렬 -> 데이터가 많아 하나의 배열에 저장하여 정렬할 수 없는 경우
	
	버블 정렬 -> 이웃한 두 요소의 대소 관계를 비교하여 정렬(단순 교환 정렬)
			->  1~n-1 합 n(n-1)/2 -> 교환 횟수의 평균 (1/2)
			->  교환 시 3회 발생
		     	== 시간 복잡도 3n(n-1)/4
 
	단순 선택 정렬 -> 가장 작은 요소를 선택해 맨앞의 요소와 교환 -> 반복
		        -> 시간 복잡도 n(n-1)/2
			 	ㄴ 한계점: 중복되는 요소가 있을 시 안정적이지 않음(바꿔줄 필요없는데 바꿔서)

	단순 삽입 정렬, 셀정렬 

	퀵정렬 : 가장 빠른 정렬 알고리즘
		-> pl,pr, 피벗 값을 기준으로 크기로 배열을 나누어 정렬
		-> 분할후 재귀하여 반복 수행 -> 비재귀 방법으로 스텍 사용
		-> 요솟수가 많은 그룹을 먼저 푸시하면, 적은 그룹이 먼저 정렬 -> 스텍의 깊이가 낮아짐
									 ㄴ 데이터가 수백만개여도 스텍 용량은 20으로 충분
		-> 3개의 요소를 선택해 정렬 후 퀵정렬시 시간복잡도 nlog(n) 최악의 경우 n^2

	병합정렬 : 배열의 요솟수가 2개까지 나눈후 대소 비교 및 병합하여 정렬
		  -> 정렬된 배열의 병합과정에서의 시간복잡도는 O(n)
			->이후 배열을 나누며 정렬의 시각복잡도느 log(n)임으로 총 시간 복잡도는 nlog(n)
			-> 서로 떨어져있는 요소를 교환하는 경우가 없기 때문에 안정적인 정렬 방법임

	Array.sort() : 
			-> primitive 타입 배열의 경우 안정적이지 않음( 퀵 정렬)
			-> 클래스 객체 배열(병합 정렬) 안정적
				-> 자연스러운 순서의 경우
					 static void sort(Object[] a) or static void sort(Object[] a,int fromIndex, toIndex)
				-> 부자연스러운 순서의 경우
					static <T> void sort(T[] a, Comparator<? super T> c) 
					static void sort(T[] a,, int fromIndex, int toIndex,  Comparator<? super T> c)

	힙 정렬 : 힙 -> 부모값이 자식 보다 항상 크다라는 조건을 만족하는 완전이진     (완전 : 부모가 자식을 왼쪽부터 추가, 이진 : 자식2개)
								          트리(트리의 가장 윗부분 : 루트)
		   -> 부모 자식의 관계는 일정하지만, 형제 사이의 대소관계는 일정하지 않음(동일 형제에서 왼쪽값이 클수도)
		   -> 단순 선택 시간 복잡도 O(n^2) 힙정렬 시간 복잡도 (nlog(n))

	도수 정렬 : 요소의 대소관계를 판단하지 않고, 빠르게 정렬 (도수분포표->누적도수분포표->목표 배열 생성 -> 배열 복사) 4단계로 구현
		

					 
13. 문자열 검색
	m: 패턴의 문자수(검색 문자열) n : 텍스트 문자수(검색 지역)
	브루트-포스법  : 선형검색을 확장한 알고리즘 (단순법, 소박법) 특정 문자열 패턴을 배열 인덱스 순서로 검색
			시간복잡도 : O(mn) ->실질적 시간복잡도 O(n)

	부호화(encoding : 정보의 모양이나 형식을 다른 모양이나 형식으로 변환 ->표준화,보안 ,처리 속도 향상, 저장 공간 절약 등에 사용
			ex) str.getBytes() -> 문자열을 바이트 시퀀스로 부호화하여 바이트 배열에 넣어둠
								ㄴ 인코딩 방식에 따라 한글 2바이트(euc-kr), 3바이트(utf-8)
							ㄴ 바이트 시퀀스는 기계가 처리하는 문자 형식 ->문자를 표현하는 바이트

	KMP 법 :검사한 결과를 버리지 않고 이를 재사용하는 알고리즘
		텍스트와 패턴 사이에 중복되는 부분을 찾아 검사를 다시 시작할 위치를 한번에 많이 옮김
		본인과 동일한 패턴을 비교하여 중복시 검색 시작 지점에 대한 값을 표로 만드는 것이 핵심
		보이어-모어법 보다는 성능이 같거나 낮아 잘 사용되지는 않음
		시간복자도 : 최악의 경우 O(n) -> 패턴 안에 반복 요소없으면 효율 낮음
	
	보이어-무어법 : 문자 패턴의 마지막 문자 부터 앞쪽으로 검사를 진행하면서 일치하지 않는 문자가 있으면 미리 준비한 표에 따라
		        옮길 크기를 정함
			최악의 경우 O(n), 평균적으로 O(n/m)
			

14. I/O, Stream, Buffer 
	자바의 I/O는 스트림을 통해 이루어짐, 스트림은 Byte형태로 데이터를 운반하는 통로(큐 구조)
					  ㄴ 큐 구조로 하나의 스트림은 한가지 역할 밖에 못함
					  ㄴ Source - InputStream - OutputStream - Sink(데이터 종착점)
						      ㄴ System.in    ㄴSystem.out
						      ㄴ 하나의 값만 받을 수 있어 이를 보안하기위해 I/OStreamWriter 사용

	Buffer : StreamWriter의 경우 배열로 값을 여러개 받게 되는데 고정적인 크기를 받아 효율이 안좋음
		이를 보안하기 위해 가변적인 값을 받는 버퍼 사용
		버퍼에 값을 계속 저장하다 버퍼가 가득차거나 개행문자 나타나면 버퍼의 내용을 한번에 전송 -> 처리속도가 좋음
			ㄴ 엔터로만 경계를 인식함 띄어쓰기를 사용할 경우 데이터를 가공해야 함
			ㄴ 기본 타입 String

15 리스트 : 데이터를 순서대로 나열해 놓은 자료구조
	
	선형리스트 : 배열처럼 연속하는(linear) 메모리 공간에 저장되어 순서를 갖음
		선형리스트의 노드 삽입 삭제
			쌓을 수 있는 데이터 최대 크기 알아야 함
			삽입,삭제 시 많은 데이터를 옮겨야 하여 효율이 안좋음
	연결리스트 : 각각의 데이터 안에 다음 데이터 정보를 갖고 있음
	노드 : 리스트에 있는 개별 요소를 뜻함
		
	배열 커서 연결 리스트 : 각 노드를 배열 안의 요소에 저장하여 연결리스트 구현 및 프리 리스트(빈칸 목록)을 통해 삭제 데이터 보관
	이중 연결리스트 : 앞쪽 노드를 찾기 어렵다는 점을 보완한 자료구조
	원형 연결리스트 : 꼬리노드가 머리 노드의 포이턴
	이중원형 연결리스트 : 머리노드와 꼬리노드 주소를 저장한 더미노드를 통해 이중 원형의 개념을 합친 연결리스트

cf) 자바에서 메서드를 오버라이딩할때 접근 제한 강화를 못함 -> ex) toString public으로 정의해야 함 

16. 트리
	
	루트 : 트리에 가장 윗부분에 위치하는 노드 -> 부모를 가지지 않음
	리프 : 트리의 가장 아랫부분에 위치하는 노드 -> 끝(terminal)노드, 바깥(external) 노드 -> 가지(자식)를 가지지 않는 노드
	안쪽 노드 : 루트 리프를 제외한 노드 (non-termianl node)
	레벨 : 루트에서 얼마나 떨어져있는 나타냄 ( 루트는 0레벨)
	차수 : 자식의 수
	높이 : 레벨의 최대값
	순서 트리 : 형제 노드 사이의 순서관계를 따지는 노드 -. 무순서 트리 : 순서관계 x

	순서 트리 탐색 방법 :
		너비 우선 : 낮은 레벨에서 부터 왼쪽부터 오른쪽으로 탐색
		깊이 우선 : 리프에 이를때까지 탐색후 부모로 돌아가 다시 반복
				자식이 2개 인경우 노드를 지나는 횟수는 3회
			   전외 순회 : 노드방분 ->  왼쪽자식 -> 오른쪽' 자식
		  	   중외 순회 : 왼쪽자식 -> 노드방문 -> 오른쪽 자식
			   후외 순회  : 왼쪽자식 -> 오른쪽 자식 -> 노드 방분

	이진 검색트리
		조건 : 노드 N을 기준으로 왼쪽 서브트리 노드의 모든 키값은 N의 키값 보다작음
		        오른쪽 서브트리 노드의 키값은 노드 N의 키값보다 큼
		
		-> 구조가 단순 /중외 순회시 오름차순 노드를 얻음 / 이진 검색과 비슷한 방식으로 빠른 검색 / 노드 삽입이 쉬움

17. 해시(hash) : 검색,추가,삭제를 효율적으로 수행

	정렬된 배열에서 추가 및 삭제 : 이진 검색 후 검색 대상 이후의 요소를 모두 뒤로 이동 -> 요소 이동에 따른 복잡도 O(n) -> 비용이 큼
	
					┌ 해시 함수
	해시 법 : 데이터를 저장할 위치를 간단한 연산으로 구함 == 해시값을 구함 -> 데이터 접근에 사용됨
			ㄴ ex) 배열의 요소수로 키값을 나눈 나머지 값으로 해시 테이블 생성
									ㄴ 해시 테이블의 요소를 버킷(bucket) 이라 함			
	충돌 : 저장할 버킷이 중복되는 현상 -> 충돌이 없을시 시간복자도 O(1)
		해결법
		-> 해시값이 같은 요소를 연결리스트로 관리
		-> 오픈 주소법 : 빈 버킷을 찾을때 까지 해시를 반복

	
	체인법(chaining,open hashing) : 해시값이 같은 데이터를 연결리스트로 관리

	오픈주소법(open addressing,closed hashing) : rehashing하여 비어있는 버킷을 찾아냄
		rehashing : 키값에 1을 더하여 다시 해시 함수 적용
		삭제 : 삭제 마침 상태로 표현하여 rehashing된 요소를 찾아냄 검색에도 이상태를 적용하여 검색함